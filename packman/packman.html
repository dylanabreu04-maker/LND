<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Pac-Man simple</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { background:#000; display:flex; align-items:center; justify-content:center; height:100vh; margin:0; color:#fff; font-family:Arial,Helvetica,sans-serif; }
  canvas { image-rendering: pixelated; border: 6px solid #222; background:#000; }
  #ui { position: absolute; top: 12px; left: 12px; color: #fff; }
  #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.75); padding: 20px 30px; border-radius:8px; display:none; }
  button { margin-top:10px; padding:6px 12px; border-radius:6px; border:none; background:#ffcc00; cursor:pointer; }
</style>
</head>
<body>
<div id="ui">Puntos: <span id="score">0</span></div>
<canvas id="game" width="560" height="620"></canvas>
<div id="msg"><div id="msgText"></div><button id="restart">Reiniciar</button></div>

<script>
// --- Configuración básica ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const tileSize = 20;
const cols = 28; // ancho del mapa en tiles
const rows = 31; // alto del mapa en tiles
const scoreEl = document.getElementById('score');
const msg = document.getElementById('msg');
const msgText = document.getElementById('msgText');
const restartBtn = document.getElementById('restart');

canvas.width = cols * tileSize;
canvas.height = rows * tileSize;

// Mapa simple: 0 = vacío/pastilla, 1 = pared, 2 = vacío sin pastilla (pasillo)
const level = [
  // 28 columnas por fila; mapa simplificado (31 filas)
  // Usa 1 para muros, 0 para pastilla, 2 para espacio vacío sin pastilla (ej. spawn)
  // Este es un mapa sencillo inspirado en Pac-Man (no exacto)
  "1111111111111111111111111111",
  "1000000000111000000000000001",
  "1011110110111011011110111101",
  "1000000110000001100000110001",
  "1011101110111011110111101111",
  "1000100000100000000100001001",
  "1110101110111011110111010111",
  "1000000000000000000000000001",
  "1011101111111111111110111011",
  "1000001000000000000010000001",
  "1111101010111011101010111111",
  "0000001010000000101010000000",
  "1111111010111111101011111111",
  "0000000010000000001000000000",
  "1111111010111111101011111111",
  "1000001000000000000010000001",
  "1011101111111111111110111011",
  "1000000000000000000000000001",
  "1110101110111011110111010111",
  "1000100000100000000100001001",
  "1011101110111011110111101111",
  "1000000110000001100000110001",
  "1011110110111011011110111101",
  "1000000000111000000000000001",
  "1111111111111111111111111111",
  // relleno para conseguir 31 filas:
  "2222222222222222222222222222",
  "2222222222222222222222222222",
  "2222222222222222222222222222",
  "2222222222222222222222222222",
  "2222222222222222222222222222",
  "2222222222222222222222222222",
  "2222222222222222222222222222"
].slice(0, rows).map(r => r.split('').map(Number));

// --- Estado del juego ---
let pellets = []; // posiciones de pastillas
let score = 0;
let gameOver = false;
let gameWin = false;

// Jugador (Pac-Man)
const player = {
  x: 14, // en tiles
  y: 23,
  dir: {x:0,y:0},
  nextDir: {x:0,y:0},
  speed: 6, // pixels por segundo (se usa movimiento por tiles)
  radius: tileSize/2 - 2
};

// Fantasma simple
const ghost = {
  x: 14,
  y: 11,
  dir: {x:1,y:0},
  speed: 4, // más lento que player
  radius: tileSize/2 - 3,
  color: '#FF6666'
};

// Inicializar pastillas en tiles con 0
function initPellets(){
  pellets = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(level[r][c] === 0){
        pellets.push({x:c, y:r, eaten:false});
      }
    }
  }
  // actualizar contador visual
  score = 0;
  scoreEl.textContent = score;
}

// Utilidades de colisión con muro
function isWall(tx, ty){
  if(tx < 0 || tx >= cols || ty < 0 || ty >= rows) return true;
  return level[ty][tx] === 1;
}

// Convertir coordenadas de tile a pixel (centro)
function tileToPixelX(tx){ return tx * tileSize + tileSize/2; }
function tileToPixelY(ty){ return ty * tileSize + tileSize/2; }

// Control teclado
const keyMap = {
  ArrowUp: {x:0,y:-1},
  ArrowDown: {x:0,y:1},
  ArrowLeft: {x:-1,y:0},
  ArrowRight: {x:1,y:0},
  w: {x:0,y:-1},
  s: {x:0,y:1},
  a: {x:-1,y:0},
  d: {x:1,y:0},
};
window.addEventListener('keydown', e=>{
  const k = e.key;
  if(keyMap[k]){
    player.nextDir = keyMap[k];
    e.preventDefault();
  }
});

// Reinicio
function restart(){
  player.x = 14; player.y = 23; player.dir = {x:0,y:0}; player.nextDir={x:0,y:0};
  ghost.x = 14; ghost.y = 11; ghost.dir = {x:1,y:0};
  gameOver = false; gameWin = false;
  msg.style.display = 'none';
  initPellets();
  lastTime = performance.now();
  requestAnimationFrame(loop);
}
restartBtn.addEventListener('click', restart);

// --- Lógica de movimiento en rejilla (simple, tile-based) ---
// Intentamos cambiar de dirección si el jugador lo solicita y no hay muro
function tryChangeDir(entity){
  const nx = entity.x + entity.nextDir.x;
  const ny = entity.y + entity.nextDir.y;
  if(!isWall(nx, ny)){
    entity.dir = {...entity.nextDir};
  }
}

// Avanza entidad una tile si su dirección lo permite
function moveEntity(entity, dt){
  // dt en segundos. Para simplicidad el movimiento es discreto por tiles:
  // acumulamos un "timer" (representado por speed*dt) y movemos cuando >=1 tile.
  // Aquí hacemos movimiento por pasos fraccionarios para suavizar.
  if(entity.nextDir && (entity !== player ? false : true)){
    // para player intentamos cambiar dirección si es posible
    tryChangeDir(entity);
  }

  // comprobar próximo tile
  const targetX = entity.x + entity.dir.x;
  const targetY = entity.y + entity.dir.y;
  if(entity.dir.x === 0 && entity.dir.y === 0) return;

  if(!isWall(targetX, targetY)){
    // mover con probabilidad proporcional a velocidad*dt: simplificamos a movimiento por tiles
    // para mantener coherencia con rejilla, usaremos un desplazamiento gradual:
    const movePixels = (entity.speed * dt); // pixels
    // Convertir movimiento a fracción de tile
    const moveTiles = movePixels / tileSize;
    // Hacemos un movimiento parcial: acumulador
    if(!entity._acc) entity._acc = 0;
    entity._acc += moveTiles;
    while(entity._acc >= 1){
      entity.x += entity.dir.x;
      entity.y += entity.dir.y;
      entity._acc -= 1;
    }
    // Limit: si el siguiente tile después de mover es un muro, detenemos en la frontera
    const nextTx = entity.x + entity.dir.x;
    const nextTy = entity.y + entity.dir.y;
    if(isWall(nextTx, nextTy)){
      // nada: se quedará esperando
    }
  } else {
    // si hay muro en la dirección actual, frenamos la entidad (para el jugador)
    entity.dir = {x:0,y:0};
  }
}

// Movimiento del fantasma: comportamiento simple mezclando persecución y aleatorio
function ghostAI(dt){
  // Intenta moverse hacia el jugador con cierta probabilidad
  const chaseProb = 0.85; // 85% intenta perseguir, 15% giro aleatorio
  if(Math.random() > chaseProb){
    // gira aleatorio a una dirección posible
    const choices = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].filter(d=>{
      return !isWall(ghost.x + d.x, ghost.y + d.y);
    });
    if(choices.length){
      ghost.dir = choices[Math.floor(Math.random()*choices.length)];
    }
  } else {
    // intenta aproximarse en x o y
    const dx = player.x - ghost.x;
    const dy = player.y - ghost.y;
    let preferred;
    if(Math.abs(dx) > Math.abs(dy)){
      preferred = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
    } else {
      preferred = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
    }
    // si preferred bloqueado -> intenta otra axis o aleatorio
    if(!isWall(ghost.x + preferred.x, ghost.y + preferred.y)){
      ghost.dir = preferred;
    } else {
      const alt = Math.abs(dx) > Math.abs(dy) ? (dy>0?{x:0,y:1}:{x:0,y:-1}) : (dx>0?{x:1,y:0}:{x:-1,y:0});
      if(!isWall(ghost.x + alt.x, ghost.y + alt.y)){
        ghost.dir = alt;
      } else {
        // elegir cualquiera posible
        const choices = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].filter(d=>{
          return !isWall(ghost.x + d.x, ghost.y + d.y);
        });
        if(choices.length) ghost.dir = choices[Math.floor(Math.random()*choices.length)];
      }
    }
  }

  moveEntity(ghost, dt);
}

// Comer pastillas
function checkPellets(){
  for(let p of pellets){
    if(!p.eaten && p.x === player.x && p.y === player.y){
      p.eaten = true;
      score += 10;
      scoreEl.textContent = score;
    }
  }
  // comprobar victoria: todas las pastillas comidas
  if(pellets.every(p => p.eaten)) {
    gameWin = true;
    gameOver = true;
    showMessage("¡Ganaste! Todos los puntos recogidos.");
  }
}

// Detectar colisión entre jugador y fantasma (en la misma tile)
function checkGhostCollision(){
  if(player.x === ghost.x && player.y === ghost.y){
    gameOver = true;
    showMessage("Te atrapó el fantasma. Fin del juego.");
  }
}

// Mostrar mensaje
function showMessage(text){
  msgText.textContent = text;
  msg.style.display = 'block';
}

// --- Dibujado ---
function drawMap(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const v = level[r][c];
      if(v === 1){ // pared
        ctx.fillStyle = '#0033cc';
        ctx.fillRect(c*tileSize, r*tileSize, tileSize, tileSize);
        // pequeño borde
        ctx.strokeStyle = '#001a66';
        ctx.strokeRect(c*tileSize+1, r*tileSize+1, tileSize-2, tileSize-2);
      } else {
        // suelo
        ctx.fillStyle = '#000';
        ctx.fillRect(c*tileSize, r*tileSize, tileSize, tileSize);
      }
    }
  }
  // pastillas
  for(const p of pellets){
    if(!p.eaten){
      const px = tileToPixelX(p.x);
      const py = tileToPixelY(p.y);
      ctx.beginPath();
      ctx.fillStyle = '#FFD700';
      ctx.arc(px, py, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

function drawPlayer(){
  const px = tileToPixelX(player.x);
  const py = tileToPixelY(player.y);
  // Pac-Man como círculo amarillo con "boca" según dirección
  ctx.fillStyle = '#FFEB3B';
  const angle = Math.atan2(player.dir.y, player.dir.x);
  let start = 0.25*Math.PI, end = 1.75*Math.PI;
  if(player.dir.x === 1) { start = 0.25*Math.PI; end = 1.75*Math.PI; }
  else if(player.dir.x === -1) { start = 1.25*Math.PI; end = 0.75*Math.PI; }
  else if(player.dir.y === -1) { start = 1.75*Math.PI; end = 1.25*Math.PI; }
  else if(player.dir.y === 1) { start = 0.75*Math.PI; end = 0.25*Math.PI; }
  else { start = 0; end = Math.PI*2; }
  ctx.beginPath();
  ctx.moveTo(px, py);
  ctx.arc(px, py, player.radius, start, end);
  ctx.closePath();
  ctx.fill();
}

function drawGhost(){
  const px = tileToPixelX(ghost.x);
  const py = tileToPixelY(ghost.y);
  // cuerpo simple
  ctx.fillStyle = ghost.color;
  ctx.beginPath();
  ctx.arc(px, py - 2, ghost.radius, Math.PI, 0);
  ctx.fill();
  // cuerpo inferior cuadrado
  ctx.fillRect(px - ghost.radius, py - 2, ghost.radius*2, ghost.radius+2);
  // ojos
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(px - 6, py - 4, 3, 0, Math.PI*2); ctx.fill();
  ctx.beginPath();
  ctx.arc(px + 2, py - 4, 3, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(px - 6, py - 4, 1.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath();
  ctx.arc(px + 2, py - 4, 1.5, 0, Math.PI*2); ctx.fill();
}

// --- Bucle principal ---
let lastTime = performance.now();
function loop(now){
  if(gameOver) return;
  const dt = (now - lastTime) / 1000; // segundos desde último frame
  lastTime = now;

  // Lógica de jugador: intentar cambiar dirección y mover
  tryChangeDir(player);
  moveEntity(player, dt);

  // Fantasma IA y movimiento
  ghostAI(dt);

  // Comprobar colisiones y pastillas
  checkPellets();
  checkGhostCollision();

  // Dibujar
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();
  drawPlayer();
  drawGhost();

  // Request next frame
  requestAnimationFrame(loop);
}

// Inicializar y empezar
initPellets();
lastTime = performance.now();
requestAnimationFrame(loop);

// Mensaje si se cierra el bucle: mostrar victoria/derrota (ya controlado en funciones)
window.addEventListener('blur', ()=>{ /* pausar en segundo plano si quieres */ });

</script>
</body>
</html>